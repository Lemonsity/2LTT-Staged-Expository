The purpose of staged compilation is to write expressive metaprograms that generate code with the guarantees that the generated code is well-formed. To justify the well-formedness of the code output, the model of two-level type theory (2LTT) \cite{2ltt} is employed as a formal typing system for staged compilation. While languages such as MetaML \cite{10.1145/258994.259019} supports metaprogramming, 2LTT additionally supports dependent types. 
% Therefore, 2LTT can ensure that each metaprogram generates a well-formed output code and provide the additional expressiveness from dependent types.
Therefore, 2LTT contributes to the field of programming language and type theory by introducing dependent types to metaprogramming.

% Staged compilation is the process of compiling a program from one language to another through a staging algorithm. For a compiled language, the compiler translates the source code written in the compile time language to a program written in the runtime language, often as the language of CPU instructions. In languages that support code generation, there also exist two stages between programs with code-generating annotations (e.g. macros, generics, function inlining) to an output code without these annotations (e.g. by substituting the inlined function inside the body of the caller function). In the case of annotations as additional syntax for the compile time language, the compiler performs staged compilation by staging these annotations away; in other words, it substitutes these annotations with code in the runtime language.

% Examples of code generation with staged compilation include macros in C and generics in Rust. The preprocessor of C takes the source code and substitutes each usage of macros with their corresponding replacement code, thus performing code generation. The Rust compiler behaves similarly with respect to programs that uses generic functions: it makes copies of each generic function with the type parameters substituted by concrete types.

In this paper, we focus on metaprogramming with two stages. We index these stages as stage $0$ and stage $1$. Each stage has a language which we will further formalise into a type system. We use the term \emph{staging algorithm} to refer the process of transforming (i.e. staging) a metaprogram to a program that only uses the stage $0$ language. A metaprogram is a term with stage $0$ type but uses type/terms from the stage $1$ language through staging annotations. To explain how a metaprogram can use stage $1$ language despite being at stage $0$, we first describe the interaction between these two stages.

